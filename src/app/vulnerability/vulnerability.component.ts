import {Component, Input, ViewChild} from '@angular/core';
import {Vulnerability, VulnerabilityStep} from '../models/vulnerability';
import {BackendService} from '../backend.service';
import 'rxjs/add/operator/do';
import 'rxjs/add/observable/interval';
import {Observable} from 'rxjs/Observable';
import 'rxjs/add/operator/share';

/**
 * Represents a number of consecutive steps in one file.
 */
class StepsInOneFile {
  path: string;
  content: string;
  content$: Observable<string>;
  codeLenses: object[];
  deltaDecorations: object[];
  stepsRange: {first: number, last: number};
  steps: VulnerabilityStep[];
}

@Component({
  selector: 'app-vulnerability',
  templateUrl: './vulnerability.component.html',
  styleUrls: ['./vulnerability.component.css']
})
export class VulnerabilityComponent {
  code: string;
  codeLenses: object[];
  deltaDecorations = [];
  fileSteps: StepsInOneFile[];
  numberOfSteps: number;
  selectedStepIndex: number;
  scrollOffset = 0;

  @ViewChild('codeEditors') codeEditors: any;

  constructor(private backend: BackendService) {
  }

  private _vulnerability: Vulnerability;

  get vulnerability(): Vulnerability {
    return this._vulnerability;
  }

  @Input() set vulnerability(v: Vulnerability) {
    this._vulnerability = v;
    if (!v) {
      return;
    }

    this.numberOfSteps = v.steps.length;
    this.fileSteps = this.buildFileSteps(v.steps);
    this.selectedStepIndex = this.numberOfSteps - 1;
  }

  private static buildDeltaDecorations(steps: VulnerabilityStep[]): object[] {
    return steps.map(step => {
      return {
        range: {
          startLineNumber: step.startLocation.line,
          startColumn: step.startLocation.column,
          endLineNumber: step.endLocation.line,
          endColumn: step.endLocation.column + 1
        },
        options: {
          inlineClassName: 'vulnerability'
        }
      };
    });
  }

  private static buildCodeLenses(steps: VulnerabilityStep[]): object[] {
    return steps.map(step => {
      return {
        range: {
          startLineNumber: step.startLocation.line,
          startColumn: step.startLocation.column,
          endLineNumber: step.endLocation.line,
          endColumn: step.endLocation.column
        },
        id: step.description,
        command: {
          title: step.description
        }
      };
    });
  }

  private buildFileSteps(steps: VulnerabilityStep[]): StepsInOneFile[] {
    // Number steps
    steps.forEach((step, i) => {
      if (!step.isNumbered) {
        step.description = `Step ${i + 1}: ${step.description}`;
        step.isNumbered = true;
      }
    });

    // Group steps by file
    const reduction = steps.reduce((acc, step) => {
      if (!acc.currentSteps) {
        acc.currentSteps = {path: step.startLocation.file, steps: [step]};
      } else if (acc.currentSteps.path === step.startLocation.file) {
        // previous child and this child are in the same file
        acc.currentSteps.steps.push(step);
      } else {
        // file location has changed
        acc.completedSteps.push(acc.currentSteps);
        acc.currentSteps = {path: step.startLocation.file, steps: [step]};
      }
      return acc;
    }, {completedSteps: [], currentSteps: undefined});
    const result = reduction.completedSteps.concat(reduction.currentSteps);

    let numberOfHandledSteps = 0;
    // Add additional data to steps
    result.forEach(fileSteps => {
      fileSteps.deltaDecorations = VulnerabilityComponent.buildDeltaDecorations(fileSteps.steps);
      fileSteps.codeLenses = VulnerabilityComponent.buildCodeLenses(fileSteps.steps);
      fileSteps.content$ = this.backend.readFile(fileSteps.path).map(s => s.toString());
      fileSteps.stepsRange = {first: numberOfHandledSteps, last: numberOfHandledSteps + fileSteps.steps.length - 1};
      numberOfHandledSteps += fileSteps.steps.length;
    });
    return result;
  }

  showPreviousStep() {
    this.selectedStepIndex = Math.max(this.selectedStepIndex - 1, 0);
  }

  showNextStep() {
    this.selectedStepIndex = Math.min(this.selectedStepIndex + 1, this.numberOfSteps - 1);
  }

  scrollToStep() {
    this.codeEditors.nativeElement.scrollTop = this.scrollOffset;
  }

  onDidScrollTo(ev) {
    if (ev) {
      this.scrollOffset = ev.offsetParent.offsetTop - 154;
      this.codeEditors.nativeElement.scrollTop = this.scrollOffset;
    }
  }

}
